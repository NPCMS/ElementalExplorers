// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
AppendStructuredBuffer<float4x4> Result;

Texture2D<float> _Mask;
Texture2D<float> _Heightmap;
float _MinHeight;
float _HeightScale;
float _TerrainWidth;
uint _InstanceWidth;

float _Scale;
float _ScaleJitter;
float _CellSize;

SamplerState SmpMirrorBilinear;

float RandomRange(float2 Seed, float Min, float Max)
{
    float randomno =  frac(sin(dot(Seed, float2(12.9898, 78.233)))*43758.5453);
    return lerp(Min, Max, randomno);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float3 pos = float3(id.x, 0, id.y) * _CellSize;
    pos.x += RandomRange(pos.xz, 0, _CellSize);
    pos.z += RandomRange(pos.xz + float2(11.5391f, 91.2159f), 0, _CellSize);
    float2 uv = pos.xz / _TerrainWidth;
    if (_Mask.SampleLevel(SmpMirrorBilinear, uv, 0) < 0.5f)
    {
        return;
    }
    pos.y = _MinHeight + _HeightScale * _Heightmap.SampleLevel(SmpMirrorBilinear, uv, 0);

    
    float angle = RandomRange(pos.xz, -3.14f, 3.14f);
    float4x4 translate = 
    {
        1.f,0.f,0.f,pos.x,
        0.f,1.f,0.f,pos.y, 
        0.f,0.f,1.f,pos.z,
        0.f,0.f,0.f,1.f
    };
    
    float sinAngle = sin(angle);
    float cosAngle = cos(angle);
    
    float4x4 rotation =
    {
        cosAngle,0.f,-sinAngle,0.f,
        0.f,1.f,0.f,0.f,
        sinAngle,0.f,cosAngle,0.f,
        0.f,0.f,0.f,1.f
    };
    float scaleAmount = _Scale + RandomRange(pos.xz, -_ScaleJitter, _ScaleJitter);
    
    float4x4 scale =
    {
        scaleAmount, 0.f,0.f,0.f,
        0.f,scaleAmount,0.f,0.f,
        0.f,0.f,scaleAmount,0.f,
        0.f,0.f,0.f,1
    };

    float4x4 mat = mul(translate, mul(rotation, scale));
    Result.Append(mat);
}
