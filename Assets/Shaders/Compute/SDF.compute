// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float> Input;
RWTexture2D<float> Result;
SamplerState SmpRepeatLinear;
float _Amount;
uint _Width;

float SmpTex(float2 id)
{
    if (min(id.x, id.y) < 0 || max(id.x, id.y) >= _Width)
    {
        return 0;
    }
    return Input.SampleLevel(SmpRepeatLinear, (id.xy + 0.5f)/ float(_Width), 0);
}

float Gradient(float2 id, float2 dotDir)
{
    float origin = SmpTex(id);
    float gradient = 0;
    for (float i = -1; i <= 1; i++)
    {
        for (float j = -1; j <= 1; j++)
        {
            float2 dir = float2(i, j);
            float2 pos = float2(id + dir);
            float flow = max(0.0f, origin - SmpTex(pos));
            gradient += max(0.0f, dot(flow * dir, dotDir));
        }
    }

    return gradient;
}

float Flow(float2 id)
{
    float origin = SmpTex(id);
    float flowAmount = 0;
    for (float i = -1; i <= 1; i++)
    {
        for (float j = -1; j <= 1; j++)
        {
            float2 dir = float2(i, j);
            float2 pos = float2(id + dir);
            float flow = max(0.0f, origin - SmpTex(pos)) / max(1.0f, length(dir));
            flowAmount += flow;
        }
    }

    return flowAmount;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float2 gradient = 0.0f;
    float flowIn = 0;
    float2 origin = float2(id.xy);
    for (float i = -1; i <= 1; i++)
    {
        for (float j = -1; j <= 1; j++)
        {
            float2 dir = float2(i, j);
            float volume = SmpTex(origin + dir);
            float grad = Gradient(origin + dir, -normalize(dir));
            flowIn += grad / max(1.0f, length(dir));
        }
    }
    float flowOut = Flow(id.xy);
    if (!(min(id.x, id.y) < 0 || max(id.x, id.y) >= _Width))
    {
        Result[id.xy] = SmpTex(id) + (flowIn - flowOut) * _Amount;
    }
}
